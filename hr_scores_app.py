#!/usr/bin/env python3
"""
Self-contained HR Scores Viewer (Flask)

Serves the deterministic HR scores generated by generate_hr_scores.py in this folder.
Prefers hr_app/data but will fall back to ../data for compatibility.
"""
from __future__ import annotations

import os, json
from datetime import datetime
from typing import Optional, Dict

from flask import Flask, jsonify, render_template, request, abort
import time
import requests

try:
    # Reuse existing fetcher to avoid duplication
    from tools.fetch_hr_hitters import fetch_hr_hitters_for_date as _fetch_hr_hitters_for_date
except Exception:
    _fetch_hr_hitters_for_date = None

APP_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR_LOCAL = os.path.join(APP_DIR, 'data')
DATA_DIR_FALLBACK = os.path.join(os.path.dirname(APP_DIR), 'data')

def data_dir() -> str:
    return DATA_DIR_LOCAL if os.path.isdir(DATA_DIR_LOCAL) else DATA_DIR_FALLBACK

app = Flask(__name__, template_folder=os.path.join(APP_DIR, 'templates'))
# Ensure template updates reflect without full restart when developing
app.config['TEMPLATES_AUTO_RELOAD'] = True
try:
    app.jinja_env.auto_reload = True
except Exception:
    pass


def _latest_hr_scores_path(target_date: Optional[str]) -> Optional[str]:
    dd = data_dir()
    if target_date:
        p = os.path.join(dd, f'hr-scores-{target_date}.json')
        if os.path.exists(p):
            return p
    try:
        files = [f for f in os.listdir(dd) if f.startswith('hr-scores-') and f.endswith('.json')]
        if not files:
            return None
        files.sort(reverse=True)
        return os.path.join(dd, files[0])
    except FileNotFoundError:
        return None


def _load_scores(path: str) -> Dict:
    with open(path, 'r', encoding='utf-8') as f:
        return json.load(f)


def _load_json(path: str) -> Dict:
    with open(path, 'r', encoding='utf-8') as f:
        return json.load(f)


SCHED_ABBR_MAP = {
    'WSN': 'WSH', 'CHW': 'CWS', 'TBR': 'TB', 'KCR': 'KC', 'SDP': 'SD',
    'SFG': 'SF', 'KCA': 'KC', 'TBA': 'TB', 'NYA': 'NYY',
    'AZ': 'ARI', 'ARZ': 'ARI'
}
TEAM_NAME_TO_ABBR = {
    'Arizona Diamondbacks': 'ARI', 'Atlanta Braves': 'ATL', 'Baltimore Orioles': 'BAL', 'Boston Red Sox': 'BOS',
    'Chicago Cubs': 'CHC', 'Chicago White Sox': 'CWS', 'Cincinnati Reds': 'CIN', 'Cleveland Guardians': 'CLE',
    'Colorado Rockies': 'COL', 'Detroit Tigers': 'DET', 'Houston Astros': 'HOU', 'Kansas City Royals': 'KC',
    'Los Angeles Angels': 'LAA', 'Los Angeles Dodgers': 'LAD', 'Miami Marlins': 'MIA', 'Milwaukee Brewers': 'MIL',
    'Minnesota Twins': 'MIN', 'New York Mets': 'NYM', 'New York Yankees': 'NYY', 'Oakland Athletics': 'OAK',
    'Philadelphia Phillies': 'PHI', 'Pittsburgh Pirates': 'PIT', 'San Diego Padres': 'SD', 'Seattle Mariners': 'SEA',
    'San Francisco Giants': 'SF', 'St. Louis Cardinals': 'STL', 'Tampa Bay Rays': 'TB', 'Texas Rangers': 'TEX',
    'Toronto Blue Jays': 'TOR', 'Washington Nationals': 'WSH'
}


def _norm_team(abbr: str | None) -> str | None:
    if not abbr:
        return abbr
    a = abbr.upper()
    a = SCHED_ABBR_MAP.get(a, a)
    return a


def _pick_data_file(prefix: str, target_date: str | None) -> str | None:
    dd = data_dir()
    if target_date:
        p = os.path.join(dd, f"{prefix}{target_date}.json")
        if os.path.exists(p):
            return p
    # fallback to latest
    try:
        files = [f for f in os.listdir(dd) if f.startswith(prefix) and f.endswith('.json')]
        files.sort(reverse=True)
        return os.path.join(dd, files[0]) if files else None
    except FileNotFoundError:
        return None


# Primary brand colors per MLB team (hex). Keep codes aligned with our normalized team abbrs.
TEAM_COLORS = {
    'ARI': '#A71930', 'ATL': '#CE1141', 'BAL': '#DF4601', 'BOS': '#BD3039',
    'CHC': '#0E3386', 'CWS': '#27251F', 'CIN': '#C6011F', 'CLE': '#E31937',
    'COL': '#333366', 'DET': '#0C2340', 'HOU': '#EB6E1F', 'KC': '#004687',
    'LAA': '#BA0021', 'LAD': '#005A9C', 'MIA': '#00A3E0', 'MIL': '#12284B',
    'MIN': '#002B5C', 'NYM': '#002D72', 'NYY': '#0C2340', 'OAK': '#003831',
    'PHI': '#E81828', 'PIT': '#FDB827', 'SD': '#2F241D', 'SEA': '#0C2C56',
    'SF': '#FD5A1E', 'STL': '#C41E3A', 'TB': '#092C5C', 'TEX': '#003278',
    'TOR': '#134A8E', 'WSH': '#AB0003'
}

# MLB team IDs (for MLB static logo URLs)
TEAM_IDS = {
    'ARI': 109, 'ATL': 144, 'BAL': 110, 'BOS': 111, 'CHC': 112, 'CIN': 113, 'CLE': 114,
    'COL': 115, 'CWS': 145, 'DET': 116, 'HOU': 117, 'KC': 118, 'LAA': 108, 'LAD': 119,
    'MIA': 146, 'MIL': 158, 'MIN': 142, 'NYM': 121, 'NYY': 147, 'OAK': 133, 'PHI': 143,
    'PIT': 134, 'SD': 135, 'SEA': 136, 'SF': 137, 'STL': 138, 'TB': 139, 'TEX': 140,
    'TOR': 141, 'WSH': 120
}

def _team_logo_url(team_abbr: str | None) -> str:
    t = _norm_team(team_abbr) or ''
    tid = TEAM_IDS.get(t)
    if tid:
        # Primary logo path
        return f"https://www.mlbstatic.com/team-logos/team-primary-on-light/{tid}.svg"
    return "https://www.mlbstatic.com/team-logos/mlb-primary.svg"


def _hex_to_rgb(h: str) -> tuple[int, int, int]:
    h = (h or '').strip().lstrip('#')
    if len(h) == 3:
        h = ''.join([c*2 for c in h])
    try:
        return int(h[0:2], 16), int(h[2:4], 16), int(h[4:6], 16)
    except Exception:
        return (0, 0, 0)


def _text_color_for_bg(hex_color: str) -> str:
    r, g, b = _hex_to_rgb(hex_color)
    # Relative luminance approximation
    luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255.0
    return '#000000' if luminance > 0.6 else '#FFFFFF'


def _team_abbr_from_schedule_team(team_obj: dict) -> str | None:
    ab = team_obj.get('abbreviation') or team_obj.get('triCode') or team_obj.get('teamCode')
    if not ab:
        nm = team_obj.get('name') or team_obj.get('teamName') or team_obj.get('shortName')
        ab = TEAM_NAME_TO_ABBR.get(nm or '', None)
    return _norm_team(ab) if ab else None


def _find_game_for_team(schedule: dict, team_abbr: str) -> dict | None:
    games = schedule.get('games') or schedule.get('dates', [{}])[0].get('games', [])
    for g in games:
        teams_obj = g.get('teams') or {}
        home_t = teams_obj.get('home', {}).get('team', {})
        away_t = teams_obj.get('away', {}).get('team', {})
        home_abbr = _team_abbr_from_schedule_team(home_t)
        away_abbr = _team_abbr_from_schedule_team(away_t)
        if team_abbr == home_abbr or team_abbr == away_abbr:
            return g
    return None


def _opponent_for_team(schedule: dict, team_abbr: str) -> tuple[str | None, bool | None]:
    """Return (opponent_abbr, is_home) for this team from the schedule, or (None, None)."""
    g = _find_game_for_team(schedule, team_abbr)
    if not g:
        return None, None
    teams_obj = g.get('teams') or {}
    home_t = teams_obj.get('home', {}).get('team', {})
    away_t = teams_obj.get('away', {}).get('team', {})
    home_ab = _team_abbr_from_schedule_team(home_t)
    away_ab = _team_abbr_from_schedule_team(away_t)
    if team_abbr == home_ab:
        return away_ab, True
    if team_abbr == away_ab:
        return home_ab, False
    return None, None


def _games_for_date(schedule: dict) -> list[dict]:
    games = schedule.get('games') or schedule.get('dates', [{}])[0].get('games', [])
    out = []
    for g in games:
        game_pk = g.get('gamePk') or g.get('gamePk'.lower())
        teams_obj = g.get('teams') or {}
        home_t = teams_obj.get('home', {}).get('team', {})
        away_t = teams_obj.get('away', {}).get('team', {})
        home_ab = _team_abbr_from_schedule_team(home_t)
        away_ab = _team_abbr_from_schedule_team(away_t)
        if not home_ab or not away_ab or not game_pk:
            continue
        out.append({'value': str(game_pk), 'home': home_ab, 'away': away_ab, 'label': f"{home_ab} vs {away_ab}"})
    return out


def _team_game_states(schedule: dict) -> dict[str, str]:
    """Map team abbr -> state code: LIVE | FINAL | SCHEDULED (or PREVIEW)."""
    states: dict[str, str] = {}
    games = schedule.get('games') or schedule.get('dates', [{}])[0].get('games', [])
    for g in games:
        teams_obj = g.get('teams') or {}
        home_t = teams_obj.get('home', {}).get('team', {})
        away_t = teams_obj.get('away', {}).get('team', {})
        home_ab = _team_abbr_from_schedule_team(home_t)
        away_ab = _team_abbr_from_schedule_team(away_t)
        st = (g.get('status') or {})
        abs_state = (st.get('abstractGameState') or st.get('detailedState') or '').strip()
        code = 'SCHEDULED'
        if abs_state.lower().startswith('live') or abs_state.lower() in ('in progress', 'in-progress'):
            code = 'LIVE'
        elif abs_state.lower().startswith('final'):
            code = 'FINAL'
        elif abs_state.lower().startswith('preview'):
            code = 'SCHEDULED'
        if home_ab:
            states[home_ab] = code
        if away_ab:
            states[away_ab] = code
    return states


def _player_id_map(players_path: str | None) -> dict:
    if not players_path or not os.path.exists(players_path):
        return {}
    data = _load_json(players_path)
    out = {}
    for p in data.get('players', []):
        k = (p.get('name'), _norm_team(p.get('team')))
        if k[0] and k[1]:
            out[k] = p.get('mlbam_id') or p.get('id')
    return out


def _filter_sort_limit(data: Dict, team: Optional[str] = None, limit: Optional[int] = None) -> Dict:
    players = data.get('players', [])
    if team:
        players = [p for p in players if p.get('team') == team]
    players = sorted(players, key=lambda p: p.get('hr_score', 0), reverse=True)
    if limit is not None:
        players = players[:limit]
    out = dict(data)
    out['players'] = players
    out['shown_players'] = len(players)
    return out


@app.route('/api/hr-scores')
def api_hr_scores():
    date = request.args.get('date')
    team = request.args.get('team')
    limit = request.args.get('limit')
    limit_i = None
    if limit:
        try:
            limit_i = max(1, min(500, int(limit)))
        except Exception:
            limit_i = None

    path = _latest_hr_scores_path(date)
    if not path:
        return jsonify({'error': 'No hr-scores files found', 'date': date}), 404
    data = _load_scores(path)
    filtered = _filter_sort_limit(data, team=team, limit=limit_i)
    return jsonify(filtered)


@app.route('/version')
def version():
    # Simple endpoint to verify the current UI build in a running server
    return jsonify({'ui': 'cards-v1', 'date': datetime.now().isoformat()})


@app.route('/')
def index():
    date = request.args.get('date')
    team = request.args.get('team')
    game = request.args.get('game')
    try:
        limit = int(request.args.get('limit', '50'))
    except Exception:
        limit = 50

    path = _latest_hr_scores_path(date)
    if not path:
        abort(404, description='No hr-scores files found. Run generate_hr_scores.py first.')
    data = _load_scores(path)

    # Load schedule and build games list for the selected date
    dd = data_dir()
    sched_path = _pick_data_file('fresh-schedule-', date) or os.path.join(dd, 'todays-schedule.json')
    schedule = _load_json(sched_path) if sched_path and os.path.exists(sched_path) else {}
    games = _games_for_date(schedule) if schedule else []
    team_states = _team_game_states(schedule) if schedule else {}
    # Determine selected date (explicit query param or the data file's date)
    today_str = datetime.now().strftime('%Y-%m-%d')
    selected_date = date or data.get('date')
    is_today = (selected_date == today_str)

    # Optional game filter: restrict players to the selected game's teams
    if game and games:
        try:
            game_pk = str(int(game))
        except Exception:
            game_pk = None
        if game_pk:
            match = next((g for g in games if g['value'] == game_pk), None)
            if match:
                allowed = {match['home'], match['away']}
                # Pre-filter players by game teams
                data = dict(data)
                data['players'] = [p for p in data.get('players', []) if p.get('team') in allowed]

    filtered = _filter_sort_limit(data, team=team, limit=limit)

    team_codes = sorted(list({p.get('team') for p in data.get('players', []) if p.get('team')}))

    # Attach image URLs and team branding for the shown players
    players_path = _pick_data_file('player-stats-', date)
    id_map = _player_id_map(players_path)
    # schedule is already loaded above
    # Load HR hitters strictly for the selected date (no fallback), keyed by MLBAM id
    hr_hitters = {}
    try:
        if date:
            dd = data_dir()
            exact_hr_path = os.path.join(dd, f"hr-hitters-{date}.json")
            if os.path.exists(exact_hr_path):
                hr_json = _load_json(exact_hr_path)
                hr_hitters = hr_json.get('hitters') or {}
    except Exception:
        hr_hitters = {}
    for p in filtered.get('players', []):
        pid = id_map.get((p.get('name'), p.get('team')))
        if pid:
            p['image_url'] = f"https://img.mlbstatic.com/mlb-photos/image/upload/w_256,q_auto:best/v1/people/{pid}/headshot/silo/current"
            p['mlbam_id'] = int(pid)
        else:
            p['image_url'] = "https://img.mlbstatic.com/mlb-photos/image/upload/w_256,q_auto:best/v1/assets/people/placeholder/headshots/silo/67"
            p['mlbam_id'] = None
        t = _norm_team(p.get('team'))
        primary = TEAM_COLORS.get(t or '', '#444444')
        p['team_primary'] = primary
        p['team_text'] = _text_color_for_bg(primary)
        p['team_logo'] = _team_logo_url(t)
        p['team_id'] = TEAM_IDS.get(t) if t else None
        # Did this player homer on the selected date?
        if pid and str(pid) in hr_hitters:
            p['homered'] = True
            p['hr_count_on_date'] = int((hr_hitters[str(pid)] or {}).get('hr') or 1)
        else:
            p['homered'] = False
        # Opponent and matchup text
        opp, is_home = _opponent_for_team(schedule, t) if t and schedule else (None, None)
        p['opponent_team'] = opp
        if opp:
            p['matchup'] = f"{t} vs {opp}" if is_home else f"{t} @ {opp}"
        else:
            p['matchup'] = t or ''
        # Game state for badges (only meaningful for current date)
        p['game_state'] = team_states.get(t) if t else None

    return render_template('hr_scores.html',
                           date=filtered.get('date'),
                           generated_at=filtered.get('generated_at'),
                           total=filtered.get('total_players'),
                           shown=filtered.get('shown_players'),
                           limit=limit,
                           game=game,
                           team=team,
                           team_codes=team_codes,
               games=games,
               is_today=is_today,
               players=filtered.get('players', []))


@app.route('/api/player-detail')
def api_player_detail():
    date = request.args.get('date')
    name = request.args.get('name')
    team = request.args.get('team')
    if not name:
        return jsonify({'error': 'name is required'}), 400

    scores_path = _latest_hr_scores_path(date)
    if not scores_path:
        return jsonify({'error': 'No hr-scores files found', 'date': date}), 404
    scores = _load_scores(scores_path)
    # find player row
    candidates = [p for p in scores.get('players', []) if p.get('name') == name]
    if team:
        candidates = [p for p in candidates if p.get('team') == team]
    if not candidates:
        return jsonify({'error': 'player not found'}), 404
    player = candidates[0]

    # image id
    players_path = _pick_data_file('player-stats-', date)
    id_map = _player_id_map(players_path)
    pid = id_map.get((player.get('name'), player.get('team')))
    image_url = (
        f"https://img.mlbstatic.com/mlb-photos/image/upload/w_512,q_auto:best/v1/people/{pid}/headshot/silo/current"
        if pid else
        "https://img.mlbstatic.com/mlb-photos/image/upload/w_512,q_auto:best/v1/assets/people/placeholder/headshots/silo/67"
    )

    # schedule + ballpark/weather
    dd = data_dir()
    sched_path = _pick_data_file('fresh-schedule-', date) or os.path.join(dd, 'todays-schedule.json')
    schedule = _load_json(sched_path) if sched_path and os.path.exists(sched_path) else {}
    game = _find_game_for_team(schedule, player.get('team')) if schedule else None
    home_abbr = None
    opp_pitcher = player.get('opposing_pitcher')
    t = _norm_team(player.get('team'))
    # Opponent team code for modal display
    opp_team, _is_home = _opponent_for_team(schedule, t) if t and schedule else (None, None)
    if game:
        teams_obj = game.get('teams') or {}
        home_abbr = _team_abbr_from_schedule_team(teams_obj.get('home', {}).get('team', {}))
    park_team = home_abbr
    park_key = f"{park_team}_park" if park_team else None
    bw_path = _pick_data_file('ballpark-weather-', date)
    ballpark = _load_json(bw_path) if bw_path and os.path.exists(bw_path) else {}
    pf = (ballpark.get('ballpark_factors') or {}).get(park_key or '', {})
    wc = (ballpark.get('weather_conditions') or {}).get(park_key or '', {})

    # hitter vs pitcher
    h2h = {}
    try:
        h2h_path = _pick_data_file('hitter-vs-pitcher-', date)
        if h2h_path and os.path.exists(h2h_path):
            h2h_json = _load_json(h2h_path)
            rec = ((h2h_json.get('h2h') or {}).get(name) or {}).get(opp_pitcher)
            if isinstance(rec, dict):
                h2h = rec
    except Exception:
        h2h = {}

    # Team branding for modal
    primary = TEAM_COLORS.get(t or '', '#444444')
    team_logo = _team_logo_url(t)

    detail = {
        'date': scores.get('date'),
        'name': player.get('name'),
        'team': player.get('team'),
        'position': player.get('position'),
        'image_url': image_url,
        'hr_score': player.get('hr_score'),
        'stats': player.get('stats'),
        'opposing_pitcher': opp_pitcher,
        'opponent_team': opp_team,
        'factors': player.get('factors'),
        'team_primary': primary,
        'team_text': _text_color_for_bg(primary),
        'team_logo': team_logo,
        'park': {
            'team_home': home_abbr,
            'venue_name': pf.get('venue_name') or wc.get('venue_name'),
            'hr_factor': pf.get('hr_factor'),
        },
        'weather': {
            'temperature': wc.get('temperature'),
            'wind_speed': wc.get('wind_speed'),
            'wind_direction': wc.get('wind_direction'),
            'precip': wc.get('precip'),
            'roof': wc.get('roof')
        },
        'h2h': h2h
    }
    return jsonify(detail)


# Simple in-process cache for live HR lookups to avoid heavy repeated queries
_LIVE_HR_CACHE: dict[str, dict] = {}
_LIVE_HR_TTL_SEC = 90


@app.route('/api/live-hr-hitters')
def api_live_hr_hitters():
    """Return hitters who have homered for the given date.
    - If date == today and fetcher is available, compute live (cached for ~90s).
    - Else, try to load hr-hitters-<date>.json from data.
    Response: { date, hitters: { <mlbam_id>: { name, hr } } }
    """
    date = request.args.get('date') or datetime.now().strftime('%Y-%m-%d')
    today = datetime.now().strftime('%Y-%m-%d')
    # live path
    if date == today and _fetch_hr_hitters_for_date is not None:
        entry = _LIVE_HR_CACHE.get(date)
        now = time.time()
        if not entry or (now - entry.get('ts', 0)) > _LIVE_HR_TTL_SEC:
            try:
                out = _fetch_hr_hitters_for_date(date) or {'date': date, 'hitters': {}}
            except Exception:
                out = {'date': date, 'hitters': {}}
            _LIVE_HR_CACHE[date] = {'ts': now, 'data': out}
        return jsonify(_LIVE_HR_CACHE[date]['data'])

    # historical/static path
    try:
        dd = data_dir()
        p = os.path.join(dd, f'hr-hitters-{date}.json')
        if os.path.exists(p):
            return jsonify(_load_json(p))
    except Exception:
        pass
    return jsonify({'date': date, 'hitters': {}})


_GAME_STATE_CACHE: dict[str, dict] = {}
_GAME_STATE_TTL_SEC = 60


@app.route('/api/game-states')
def api_game_states():
    """Return per-team game state for a date using live MLB StatsAPI schedule.
    Response: { date, teams: { ABBR: 'LIVE'|'FINAL'|'SCHEDULED' } }
    """
    date = request.args.get('date') or datetime.now().strftime('%Y-%m-%d')
    entry = _GAME_STATE_CACHE.get(date)
    now = time.time()
    if entry and (now - entry.get('ts', 0)) <= _GAME_STATE_TTL_SEC:
        return jsonify(entry['data'])
    try:
        url = f"https://statsapi.mlb.com/api/v1/schedule?sportId=1&date={date}&hydrate=linescore"
        r = requests.get(url, timeout=15)
        sched = r.json() if r.status_code == 200 else {}
    except Exception:
        sched = {}
    out_map: dict[str, dict] = {}
    games = (sched.get('dates') or [{}])[0].get('games', []) if sched else []
    for g in games:
        teams_obj = g.get('teams') or {}
        home_t = teams_obj.get('home', {}).get('team', {})
        away_t = teams_obj.get('away', {}).get('team', {})
        home_ab = _team_abbr_from_schedule_team(home_t)
        away_ab = _team_abbr_from_schedule_team(away_t)
        st = (g.get('status') or {})
        abstract = (st.get('abstractGameState') or '').lower()
        detailed = (st.get('detailedState') or '')
        code = 'SCHEDULED'
        label = 'Scheduled'
        # Determine runs from linescore or teams score
        ls = g.get('linescore') or {}
        ls_teams = (ls.get('teams') or {}) if isinstance(ls, dict) else {}
        try:
            home_runs = (ls_teams.get('home') or {}).get('runs')
            away_runs = (ls_teams.get('away') or {}).get('runs')
        except Exception:
            home_runs = away_runs = None
        if home_runs is None:
            try:
                home_runs = teams_obj.get('home', {}).get('score')
            except Exception:
                home_runs = None
        if away_runs is None:
            try:
                away_runs = teams_obj.get('away', {}).get('score')
            except Exception:
                away_runs = None
        try:
            hr_i = int(home_runs) if home_runs is not None else None
        except Exception:
            hr_i = None
        try:
            ar_i = int(away_runs) if away_runs is not None else None
        except Exception:
            ar_i = None
        score_label = None
        if home_ab and away_ab and hr_i is not None and ar_i is not None:
            score_label = f"{away_ab} {ar_i}\u2013{hr_i} {home_ab}"

        if abstract.startswith('live') or abstract in ('in progress','in-progress'):
            code = 'LIVE'
            # Build label from linescore
            ord_inn = ls.get('currentInningOrdinal') or ls.get('currentInning')
            is_top = ls.get('isTopInning')
            half = None
            if isinstance(is_top, bool):
                half = 'Top' if is_top else 'Bot'
            else:
                # fallback to inningState like 'Top'/'Middle'/'End'
                half = (ls.get('inningState') or '').title() or 'In'
            outs = ls.get('outs')
            try:
                outs_i = int(outs)
            except Exception:
                outs_i = None
            outs_txt = (f", {outs_i} out" + ('' if outs_i == 1 else 's')) if outs_i is not None else ''
            if ord_inn:
                label = f"{half} {ord_inn}{outs_txt}"
            else:
                label = 'In Progress'
        elif abstract.startswith('final'):
            code = 'FINAL'
            label = 'Final'
        elif abstract.startswith('preview'):
            code = 'SCHEDULED'
            label = 'Scheduled'
        if home_ab:
            out_map[home_ab] = {'state': code, 'label': label or code.title(), 'score_label': score_label}
        if away_ab:
            out_map[away_ab] = {'state': code, 'label': label or code.title(), 'score_label': score_label}
    data = {'date': date, 'teams': out_map}
    _GAME_STATE_CACHE[date] = {'ts': now, 'data': data}
    return jsonify(data)


def main():
    import argparse
    parser = argparse.ArgumentParser(description='Run HR Scores Flask app (self-contained)')
    parser.add_argument('--port', type=int, default=8010)
    parser.add_argument('--host', type=str, default='127.0.0.1')
    parser.add_argument('--debug', action='store_true', help='Enable Flask debug/reloader')
    args = parser.parse_args()
    app.run(host=args.host, port=args.port, debug=bool(args.debug))


if __name__ == '__main__':
    main()

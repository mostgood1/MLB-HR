#!/usr/bin/env python3
"""
Self-contained HR Scores Viewer (Flask)

Serves the deterministic HR scores generated by generate_hr_scores.py in this folder.
Prefers hr_app/data but will fall back to ../data for compatibility.
"""
from __future__ import annotations

import os, json, re, unicodedata
from datetime import datetime
from typing import Optional, Dict

from flask import Flask, jsonify, render_template, request, abort
import time
import requests

try:
    # Reuse existing fetcher to avoid duplication
    from tools.fetch_hr_hitters import fetch_hr_hitters_for_date as _fetch_hr_hitters_for_date
except Exception:
    _fetch_hr_hitters_for_date = None

APP_DIR = os.path.dirname(os.path.abspath(__file__))
DATA_DIR_LOCAL = os.path.join(APP_DIR, 'data')
DATA_DIR_FALLBACK = os.path.join(os.path.dirname(APP_DIR), 'data')

def data_dir() -> str:
    return DATA_DIR_LOCAL if os.path.isdir(DATA_DIR_LOCAL) else DATA_DIR_FALLBACK

app = Flask(__name__, template_folder=os.path.join(APP_DIR, 'templates'))
# WSGI alias for Gunicorn when invoked as `gunicorn hr_scores_app`
application = app
# Ensure template updates reflect without full restart when developing
app.config['TEMPLATES_AUTO_RELOAD'] = True
try:
    app.jinja_env.auto_reload = True
except Exception:
    pass


def _latest_hr_scores_path(target_date: Optional[str]) -> Optional[str]:
    dd = data_dir()
    if target_date:
        p = os.path.join(dd, f'hr-scores-{target_date}.json')
        if os.path.exists(p):
            return p
    try:
        files = [f for f in os.listdir(dd) if f.startswith('hr-scores-') and f.endswith('.json')]
        if not files:
            return None
        files.sort(reverse=True)
        return os.path.join(dd, files[0])
    except FileNotFoundError:
        return None


def _tz_today_str() -> str:
    tz_name = os.environ.get('APP_TZ', 'America/Los_Angeles')
    try:
        from zoneinfo import ZoneInfo  # Python 3.9+
        return datetime.now(ZoneInfo(tz_name)).strftime('%Y-%m-%d')
    except Exception:
        # Fallback to server local time if zoneinfo not available
        return datetime.now().strftime('%Y-%m-%d')


def _load_scores(path: str) -> Dict:
    with open(path, 'r', encoding='utf-8') as f:
        return json.load(f)


def _load_json(path: str) -> Dict:
    with open(path, 'r', encoding='utf-8') as f:
        return json.load(f)


def _prob_to_american(p: float) -> Optional[int]:
    try:
        p = float(p)
    except Exception:
        return None
    p = max(1e-6, min(1 - 1e-6, p))
    if p >= 0.5:
        # negative odds
        val = -int(round(100 * p / (1 - p)))
    else:
        val = int(round(100 * (1 - p) / p))
    return val


SCHED_ABBR_MAP = {
    'WSN': 'WSH', 'CHW': 'CWS', 'TBR': 'TB', 'KCR': 'KC', 'SDP': 'SD',
    'SFG': 'SF', 'KCA': 'KC', 'TBA': 'TB', 'NYA': 'NYY',
    'AZ': 'ARI', 'ARZ': 'ARI'
}
TEAM_NAME_TO_ABBR = {
    'Arizona Diamondbacks': 'ARI', 'Atlanta Braves': 'ATL', 'Baltimore Orioles': 'BAL', 'Boston Red Sox': 'BOS',
    'Chicago Cubs': 'CHC', 'Chicago White Sox': 'CWS', 'Cincinnati Reds': 'CIN', 'Cleveland Guardians': 'CLE',
    'Colorado Rockies': 'COL', 'Detroit Tigers': 'DET', 'Houston Astros': 'HOU', 'Kansas City Royals': 'KC',
    'Los Angeles Angels': 'LAA', 'Los Angeles Dodgers': 'LAD', 'Miami Marlins': 'MIA', 'Milwaukee Brewers': 'MIL',
    'Minnesota Twins': 'MIN', 'New York Mets': 'NYM', 'New York Yankees': 'NYY', 'Oakland Athletics': 'OAK',
    'Philadelphia Phillies': 'PHI', 'Pittsburgh Pirates': 'PIT', 'San Diego Padres': 'SD', 'Seattle Mariners': 'SEA',
    'San Francisco Giants': 'SF', 'St. Louis Cardinals': 'STL', 'Tampa Bay Rays': 'TB', 'Texas Rangers': 'TEX',
    'Toronto Blue Jays': 'TOR', 'Washington Nationals': 'WSH'
}


def _norm_team(abbr: str | None) -> str | None:
    if not abbr:
        return abbr
    a = abbr.upper()
    a = SCHED_ABBR_MAP.get(a, a)
    return a


def _pick_data_file(prefix: str, target_date: str | None) -> str | None:
    dd = data_dir()
    if target_date:
        p = os.path.join(dd, f"{prefix}{target_date}.json")
        if os.path.exists(p):
            return p
    # fallback to latest
    try:
        files = [f for f in os.listdir(dd) if f.startswith(prefix) and f.endswith('.json')]
        files.sort(reverse=True)
        return os.path.join(dd, files[0]) if files else None
    except FileNotFoundError:
        return None


def _norm_name_key(name: str | None) -> str:
    s = unicodedata.normalize('NFKD', str(name or '')).encode('ascii', 'ignore').decode('ascii')
    s = s.strip()
    # Remove anything after a slash (e.g., "Shohei Ohtani/Los Angeles Dodgers")
    if '/' in s:
        s = s.split('/', 1)[0].strip()
    # Remove trailing team in parentheses e.g., "Aaron Judge (NYY)"
    s = re.sub(r"\s*\([A-Z]{2,4}\)$", '', s)
    # Remove common punctuation and compress spaces
    s = re.sub(r"[\.'â€™`-]", ' ', s)
    # Remove common name suffixes (Jr., Sr., II, III, IV, V, VI) at end
    s = re.sub(r"\s+(?i:(jr|sr|ii|iii|iv|v|vi))\.?$", '', s)
    s = re.sub(r"\s+", ' ', s).strip()
    return s.lower()


def _load_player_hr_odds(target_date: str | None) -> tuple[dict, str | None]:
    """Load player HR odds map: name(lower) -> { best_prob, best_american, offers } and source string.
    Returns ({}, None) if not available.
    """
    try:
        p = _pick_data_file('player-hr-odds-', target_date)
        if not p or not os.path.exists(p):
            return {}, None
        j = _load_json(p)
        players = j.get('players') or {}
        out = {}
        for name, rec in players.items():
            if not name:
                continue
            try:
                key = _norm_name_key(name)
                bp = rec.get('best_prob')
                ba = rec.get('best_american')
                offers = rec.get('offers') or []
                out[key] = {
                    'best_prob': float(bp) if bp is not None else None,
                    'best_american': int(ba) if ba is not None else None,
                    'offers': offers
                }
                # Also add a variant without jr/sr/roman suffix if present (non-destructive)
                alt = re.sub(r"\s+(jr|sr|ii|iii|iv|v)\b\.?$", '', key)
                if alt and alt != key and alt not in out:
                    out[alt] = out[key]
            except Exception:
                continue
        return out, (j.get('source') or None)
    except Exception:
        return {}, None


# Primary brand colors per MLB team (hex). Keep codes aligned with our normalized team abbrs.
TEAM_COLORS = {
    'ARI': '#A71930', 'ATL': '#CE1141', 'BAL': '#DF4601', 'BOS': '#BD3039',
    'CHC': '#0E3386', 'CWS': '#27251F', 'CIN': '#C6011F', 'CLE': '#E31937',
    'COL': '#333366', 'DET': '#0C2340', 'HOU': '#EB6E1F', 'KC': '#004687',
    'LAA': '#BA0021', 'LAD': '#005A9C', 'MIA': '#00A3E0', 'MIL': '#12284B',
    'MIN': '#002B5C', 'NYM': '#002D72', 'NYY': '#0C2340', 'OAK': '#003831',
    'PHI': '#E81828', 'PIT': '#FDB827', 'SD': '#2F241D', 'SEA': '#0C2C56',
    'SF': '#FD5A1E', 'STL': '#C41E3A', 'TB': '#092C5C', 'TEX': '#003278',
    'TOR': '#134A8E', 'WSH': '#AB0003'
}

# MLB team IDs (for MLB static logo URLs)
TEAM_IDS = {
    'ARI': 109, 'ATL': 144, 'BAL': 110, 'BOS': 111, 'CHC': 112, 'CIN': 113, 'CLE': 114,
    'COL': 115, 'CWS': 145, 'DET': 116, 'HOU': 117, 'KC': 118, 'LAA': 108, 'LAD': 119,
    'MIA': 146, 'MIL': 158, 'MIN': 142, 'NYM': 121, 'NYY': 147, 'OAK': 133, 'PHI': 143,
    'PIT': 134, 'SD': 135, 'SEA': 136, 'SF': 137, 'STL': 138, 'TB': 139, 'TEX': 140,
    'TOR': 141, 'WSH': 120
}

def _team_logo_url(team_abbr: str | None) -> str:
    t = _norm_team(team_abbr) or ''
    tid = TEAM_IDS.get(t)
    if tid:
        # Primary logo path
        return f"https://www.mlbstatic.com/team-logos/team-primary-on-light/{tid}.svg"
    return "https://www.mlbstatic.com/team-logos/mlb-primary.svg"


def _hex_to_rgb(h: str) -> tuple[int, int, int]:
    h = (h or '').strip().lstrip('#')
    if len(h) == 3:
        h = ''.join([c*2 for c in h])
    try:
        return int(h[0:2], 16), int(h[2:4], 16), int(h[4:6], 16)
    except Exception:
        return (0, 0, 0)


def _text_color_for_bg(hex_color: str) -> str:
    r, g, b = _hex_to_rgb(hex_color)
    # Relative luminance approximation
    luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255.0
    return '#000000' if luminance > 0.6 else '#FFFFFF'


def _team_abbr_from_schedule_team(team_obj: dict) -> str | None:
    ab = team_obj.get('abbreviation') or team_obj.get('triCode') or team_obj.get('teamCode')
    if not ab:
        nm = team_obj.get('name') or team_obj.get('teamName') or team_obj.get('shortName')
        ab = TEAM_NAME_TO_ABBR.get(nm or '', None)
    return _norm_team(ab) if ab else None


def _find_game_for_team(schedule: dict, team_abbr: str) -> dict | None:
    games = schedule.get('games') or schedule.get('dates', [{}])[0].get('games', [])
    for g in games:
        teams_obj = g.get('teams') or {}
        home_t = teams_obj.get('home', {}).get('team', {})
        away_t = teams_obj.get('away', {}).get('team', {})
        home_abbr = _team_abbr_from_schedule_team(home_t)
        away_abbr = _team_abbr_from_schedule_team(away_t)
        if team_abbr == home_abbr or team_abbr == away_abbr:
            return g
    return None


def _opponent_for_team(schedule: dict, team_abbr: str) -> tuple[str | None, bool | None]:
    """Return (opponent_abbr, is_home) for this team from the schedule, or (None, None)."""
    g = _find_game_for_team(schedule, team_abbr)
    if not g:
        return None, None
    teams_obj = g.get('teams') or {}
    home_t = teams_obj.get('home', {}).get('team', {})
    away_t = teams_obj.get('away', {}).get('team', {})
    home_ab = _team_abbr_from_schedule_team(home_t)
    away_ab = _team_abbr_from_schedule_team(away_t)
    if team_abbr == home_ab:
        return away_ab, True
    if team_abbr == away_ab:
        return home_ab, False
    return None, None


def _games_for_date(schedule: dict) -> list[dict]:
    games = schedule.get('games') or schedule.get('dates', [{}])[0].get('games', [])
    out = []
    for g in games:
        game_pk = g.get('gamePk') or g.get('gamePk'.lower())
        teams_obj = g.get('teams') or {}
        home_t = teams_obj.get('home', {}).get('team', {})
        away_t = teams_obj.get('away', {}).get('team', {})
        home_ab = _team_abbr_from_schedule_team(home_t)
        away_ab = _team_abbr_from_schedule_team(away_t)
        if not home_ab or not away_ab or not game_pk:
            continue
        out.append({'value': str(game_pk), 'home': home_ab, 'away': away_ab, 'label': f"{home_ab} vs {away_ab}"})
    return out


def _team_game_states(schedule: dict) -> dict[str, str]:
    """Map team abbr -> state code: LIVE | FINAL | SCHEDULED (or PREVIEW)."""
    states: dict[str, str] = {}
    games = schedule.get('games') or schedule.get('dates', [{}])[0].get('games', [])
    for g in games:
        teams_obj = g.get('teams') or {}
        home_t = teams_obj.get('home', {}).get('team', {})
        away_t = teams_obj.get('away', {}).get('team', {})
        home_ab = _team_abbr_from_schedule_team(home_t)
        away_ab = _team_abbr_from_schedule_team(away_t)
        st = (g.get('status') or {})
        abs_state = (st.get('abstractGameState') or st.get('detailedState') or '').strip()
        code = 'SCHEDULED'
        if abs_state.lower().startswith('live') or abs_state.lower() in ('in progress', 'in-progress'):
            code = 'LIVE'
        elif abs_state.lower().startswith('final'):
            code = 'FINAL'
        elif abs_state.lower().startswith('preview'):
            code = 'SCHEDULED'
        if home_ab:
            states[home_ab] = code
        if away_ab:
            states[away_ab] = code
    return states


def _player_id_map(players_path: str | None) -> dict:
    if not players_path or not os.path.exists(players_path):
        return {}
    data = _load_json(players_path)
    out = {}
    for p in data.get('players', []):
        k = (p.get('name'), _norm_team(p.get('team')))
        if k[0] and k[1]:
            out[k] = p.get('mlbam_id') or p.get('id')
    return out


def _filter_sort_limit(data: Dict, team: Optional[str] = None, limit: Optional[int] = None) -> Dict:
    players = data.get('players', [])
    if team:
        players = [p for p in players if p.get('team') == team]
    players = sorted(players, key=lambda p: p.get('hr_score', 0), reverse=True)
    if limit is not None:
        players = players[:limit]
    out = dict(data)
    out['players'] = players
    out['shown_players'] = len(players)
    return out


@app.route('/api/hr-scores')
def api_hr_scores():
    date = request.args.get('date') or _tz_today_str()
    team = request.args.get('team')
    limit = request.args.get('limit')
    limit_i = None
    if limit:
        try:
            limit_i = max(1, min(500, int(limit)))
        except Exception:
            limit_i = None

    path = _latest_hr_scores_path(date)
    if not path:
        return jsonify({'error': 'No hr-scores files found', 'date': date}), 404
    data = _load_scores(path)
    filtered = _filter_sort_limit(data, team=team, limit=limit_i)
    return jsonify(filtered)


@app.route('/version')
def version():
    # Simple endpoint to verify the current UI build in a running server
    return jsonify({'ui': 'cards-v1', 'date': datetime.now().isoformat()})


@app.route('/')
def index():
    # If no date query, use America/Los_Angeles today
    date = request.args.get('date')
    tz_today = _tz_today_str()
    effective_date = date or tz_today
    team = request.args.get('team')
    game = request.args.get('game')
    try:
        limit = int(request.args.get('limit', '50'))
    except Exception:
        limit = 50

    path = _latest_hr_scores_path(effective_date)
    if not path:
        abort(404, description='No hr-scores files found. Run generate_hr_scores.py first.')
    data = _load_scores(path)

    # Load schedule and build games list for the selected date
    dd = data_dir()
    sched_path = _pick_data_file('fresh-schedule-', effective_date) or os.path.join(dd, 'todays-schedule.json')
    schedule = _load_json(sched_path) if sched_path and os.path.exists(sched_path) else {}
    games = _games_for_date(schedule) if schedule else []
    team_states = _team_game_states(schedule) if schedule else {}
    # Determine selected date (explicit query param or the data file's date)
    today_str = tz_today
    selected_date = date or data.get('date') or tz_today
    is_today = (selected_date == today_str)

    # Build a full-slate sorted list for top-K metrics BEFORE any filtering
    players_all_sorted = sorted(list(data.get('players', [])), key=lambda p: p.get('hr_score', 0), reverse=True)
    # Player id map and ground truth homers for the date
    players_path = _pick_data_file('player-stats-', effective_date)
    id_map = _player_id_map(players_path)
    hr_hitters = {}
    try:
        if effective_date:
            exact_hr_path = os.path.join(dd, f"hr-hitters-{effective_date}.json")
            if os.path.exists(exact_hr_path):
                hr_json = _load_json(exact_hr_path)
                hr_hitters = hr_json.get('hitters') or {}
    except Exception:
        hr_hitters = {}

    # Compute Top-K hit rate summary using id and name fallbacks
    def _topk_summary(players_sorted: list[dict], ks=(10,20,30)):
        name_hit = set()
        try:
            for rec in (hr_hitters or {}).values():
                nm = (rec.get('name') or '').strip().lower()
                if nm:
                    name_hit.add(nm)
        except Exception:
            pass
        id_hit = set(str(k) for k in (hr_hitters or {}).keys())
        out = []
        for k in ks:
            topk = players_sorted[:k]
            hits = 0
            for p in topk:
                pid = id_map.get((p.get('name'), _norm_team(p.get('team'))))
                if pid is not None and str(pid) in id_hit:
                    hits += 1
                else:
                    nm = (p.get('name') or '').strip().lower()
                    if nm in name_hit:
                        hits += 1
            rate = (hits / k) if k > 0 else 0.0
            out.append({'k': k, 'hits': hits, 'rate': rate})
        return out
    topk_summary = _topk_summary(players_all_sorted) if hr_hitters else []

    # Optional game filter: restrict players to the selected game's teams
    if game and games:
        try:
            game_pk = str(int(game))
        except Exception:
            game_pk = None
        if game_pk:
            match = next((g for g in games if g['value'] == game_pk), None)
            if match:
                allowed = {match['home'], match['away']}
                # Pre-filter players by game teams
                data = dict(data)
                data['players'] = [p for p in data.get('players', []) if p.get('team') in allowed]

    # Load player HR odds for the effective date
    odds_map, odds_source = _load_player_hr_odds(effective_date)

    filtered = _filter_sort_limit(data, team=team, limit=limit)

    team_codes = sorted(list({p.get('team') for p in data.get('players', []) if p.get('team')}))

    # Attach image URLs and team branding for the shown players
    # schedule is already loaded above
    # HR hitters already loaded above for summary
    # Value threshold (percentage points) for showing a badge
    try:
        value_thresh_pp = float(os.environ.get('VALUE_BADGE_MIN_PP', '1.5'))
    except Exception:
        value_thresh_pp = 1.5

    for p in filtered.get('players', []):
        pid = id_map.get((p.get('name'), p.get('team')))
        if pid:
            p['image_url'] = f"https://img.mlbstatic.com/mlb-photos/image/upload/w_256,q_auto:best/v1/people/{pid}/headshot/silo/current"
            p['mlbam_id'] = int(pid)
        else:
            p['image_url'] = "https://img.mlbstatic.com/mlb-photos/image/upload/w_256,q_auto:best/v1/assets/people/placeholder/headshots/silo/67"
            p['mlbam_id'] = None
        t = _norm_team(p.get('team'))
        primary = TEAM_COLORS.get(t or '', '#444444')
        p['team_primary'] = primary
        p['team_text'] = _text_color_for_bg(primary)
        p['team_logo'] = _team_logo_url(t)
        p['team_id'] = TEAM_IDS.get(t) if t else None
        # Did this player homer on the selected date?
        if pid and str(pid) in hr_hitters:
            p['homered'] = True
            p['hr_count_on_date'] = int((hr_hitters[str(pid)] or {}).get('hr') or 1)
        else:
            p['homered'] = False
        # Opponent and matchup text
        opp, is_home = _opponent_for_team(schedule, t) if t and schedule else (None, None)
        p['opponent_team'] = opp
        if opp:
            p['matchup'] = f"{t} vs {opp}" if is_home else f"{t} @ {opp}"
        else:
            p['matchup'] = t or ''
        # Game state for badges (only meaningful for current date)
        p['game_state'] = team_states.get(t) if t else None
        # Attach odds if available
        try:
            key = _norm_name_key(p.get('name'))
            om = odds_map.get(key)
            if om:
                p['odds_prob'] = om.get('best_prob')
                p['odds_american'] = om.get('best_american')
                p['odds_source'] = odds_source
                # Vig adjustment heuristic: reduce market prob by vig / sqrt(n_offers)
                try:
                    vig_est = float(os.environ.get('HR_PROP_VIG_EST', '0.03'))
                except Exception:
                    vig_est = 0.03
                offer_count = len(om.get('offers', [])) if isinstance(om.get('offers'), list) else 1
                eff_vig = vig_est / max(1.0, offer_count ** 0.5)
                p_market_raw = om.get('best_prob')
                p_market_fair = None
                if p_market_raw is not None:
                    try:
                        p_market_raw = float(p_market_raw)
                        p_market_fair = max(0.0, min(1.0, p_market_raw * (1.0 - eff_vig)))
                    except Exception:
                        p_market_fair = None
                if p_market_fair is not None:
                    p['market_prob_fair'] = round(p_market_fair, 5)
                # Value & EV
                try:
                    p_model = p.get('model_prob')
                    if p_model is None:
                        p_model = max(0.0, min(1.0, (p.get('hr_score') or 0) / 100.0))
                    p_market_for_value = p_market_fair if p_market_fair is not None else p_market_raw
                    if p_market_for_value is not None:
                        delta_pp = (p_model - p_market_for_value) * 100.0
                        p['value_pp'] = round(delta_pp, 1)
                        p['fair_american'] = _prob_to_american(p_model)
                        amer = om.get('best_american')
                        ev = None
                        if amer is not None:
                            try:
                                amer_i = int(amer)
                                if amer_i >= 0:
                                    dec = 1 + (amer_i / 100.0)
                                else:
                                    dec = 1 + (100.0 / abs(amer_i))
                                ev = p_model * (dec - 1.0) - (1 - p_model)
                            except Exception:
                                ev = None
                        if ev is not None:
                            p['ev_best'] = round(ev, 4)
                            p['ev_positive'] = ev > 0
                        p['has_value'] = (delta_pp >= value_thresh_pp and (ev is None or ev > 0))
                        try:
                            tooltip = (
                                f"Model p: {p_model:.3f}\n" +
                                (f"Raw p: {p.get('model_prob_raw'):.3f}\n" if p.get('model_prob_raw') is not None else "") +
                                (f"Fair market p: {p_market_for_value:.3f}\n" if p_market_for_value is not None else "") +
                                (f"Delta pp: {delta_pp:.1f}\n" if p_market_for_value is not None else "") +
                                (f"EV: {p['ev_best']:.3f}" if ev is not None else "")
                            )
                            p['value_tooltip'] = tooltip.strip()
                        except Exception:
                            pass
                except Exception:
                    pass
        except Exception:
            pass

    return render_template('hr_scores.html',
                           date=filtered.get('date'),
                           generated_at=filtered.get('generated_at'),
                           total=filtered.get('total_players'),
                           shown=filtered.get('shown_players'),
                           limit=limit,
                           game=game,
                           team=team,
                           team_codes=team_codes,
               games=games,
               is_today=is_today,
               players=filtered.get('players', []),
               topk_summary=topk_summary)


@app.route('/api/player-detail')
def api_player_detail():
    date = request.args.get('date') or _tz_today_str()
    name = request.args.get('name')
    team = request.args.get('team')
    if not name:
        return jsonify({'error': 'name is required'}), 400

    scores_path = _latest_hr_scores_path(date)
    if not scores_path:
        return jsonify({'error': 'No hr-scores files found', 'date': date}), 404
    scores = _load_scores(scores_path)
    # find player row
    candidates = [p for p in scores.get('players', []) if p.get('name') == name]
    if team:
        candidates = [p for p in candidates if p.get('team') == team]
    if not candidates:
        return jsonify({'error': 'player not found'}), 404
    player = candidates[0]

    # image id
    players_path = _pick_data_file('player-stats-', date)
    id_map = _player_id_map(players_path)
    pid = id_map.get((player.get('name'), player.get('team')))
    image_url = (
        f"https://img.mlbstatic.com/mlb-photos/image/upload/w_512,q_auto:best/v1/people/{pid}/headshot/silo/current"
        if pid else
        "https://img.mlbstatic.com/mlb-photos/image/upload/w_512,q_auto:best/v1/assets/people/placeholder/headshots/silo/67"
    )

    # schedule + ballpark/weather
    dd = data_dir()
    sched_path = _pick_data_file('fresh-schedule-', date) or os.path.join(dd, 'todays-schedule.json')
    schedule = _load_json(sched_path) if sched_path and os.path.exists(sched_path) else {}
    game = _find_game_for_team(schedule, player.get('team')) if schedule else None
    home_abbr = None
    opp_pitcher = player.get('opposing_pitcher')
    t = _norm_team(player.get('team'))
    # Opponent team code for modal display
    opp_team, _is_home = _opponent_for_team(schedule, t) if t and schedule else (None, None)
    if game:
        teams_obj = game.get('teams') or {}
        home_abbr = _team_abbr_from_schedule_team(teams_obj.get('home', {}).get('team', {}))
    park_team = home_abbr
    park_key = f"{park_team}_park" if park_team else None
    bw_path = _pick_data_file('ballpark-weather-', date)
    ballpark = _load_json(bw_path) if bw_path and os.path.exists(bw_path) else {}
    pf = (ballpark.get('ballpark_factors') or {}).get(park_key or '', {})
    wc = (ballpark.get('weather_conditions') or {}).get(park_key or '', {})

    # hitter vs pitcher
    h2h = {}
    try:
        h2h_path = _pick_data_file('hitter-vs-pitcher-', date)
        if h2h_path and os.path.exists(h2h_path):
            h2h_json = _load_json(h2h_path)
            rec = ((h2h_json.get('h2h') or {}).get(name) or {}).get(opp_pitcher)
            if isinstance(rec, dict):
                h2h = rec
    except Exception:
        h2h = {}

    # Team branding for modal
    primary = TEAM_COLORS.get(t or '', '#444444')
    team_logo = _team_logo_url(t)

    # Player odds (best + offers)
    odds_best = None
    odds_offers = []
    try:
        odds_map, odds_source = _load_player_hr_odds(date)
        key = _norm_name_key(player.get('name'))
        om = odds_map.get(key)
        if om:
            odds_best = {
                'best_prob': om.get('best_prob'),
                'best_american': om.get('best_american'),
                'source': odds_source
            }
            odds_offers = om.get('offers') or []
            # Compute value details for modal
            try:
                p_model = max(0.0, min(1.0, (player.get('hr_score') or 0) / 100.0))
                p_market = float(om.get('best_prob')) if om.get('best_prob') is not None else None
                fair_amer = _prob_to_american(p_model)
                value_pp = ((p_model - p_market) * 100.0) if p_market is not None else None
            except Exception:
                fair_amer = None
                value_pp = None
        else:
            fair_amer = None
            value_pp = None
    except Exception:
        odds_best = None
        odds_offers = []
        fair_amer = None
        value_pp = None

    detail = {
        'date': scores.get('date'),
        'name': player.get('name'),
        'team': player.get('team'),
        'position': player.get('position'),
        'image_url': image_url,
        'hr_score': player.get('hr_score'),
        'stats': player.get('stats'),
        'opposing_pitcher': opp_pitcher,
        'opponent_team': opp_team,
        'factors': player.get('factors'),
        'team_primary': primary,
        'team_text': _text_color_for_bg(primary),
        'team_logo': team_logo,
        'odds': {
            'best': odds_best,
            'offers': odds_offers,
            'value': {
                'value_pp': value_pp,
                'fair_american': fair_amer
            }
        },
        'park': {
            'team_home': home_abbr,
            'venue_name': pf.get('venue_name') or wc.get('venue_name'),
            'hr_factor': pf.get('hr_factor'),
        },
        'weather': {
            'temperature': wc.get('temperature'),
            'wind_speed': wc.get('wind_speed'),
            'wind_direction': wc.get('wind_direction'),
            'precip': wc.get('precip'),
            'roof': wc.get('roof')
        },
        'h2h': h2h
    }
    return jsonify(detail)


@app.route('/api/odds-diff')
def api_odds_diff():
    """Diagnostics: list players without matched odds and odds names without a matching player for a date.
    Query: ?date=YYYY-MM-DD
    Response: { date, missing_for_players: [names], unmatched_odds_names: [names], counts: { players: n, odds: m, matched: k } }
    """
    date = request.args.get('date') or _tz_today_str()
    scores_path = _latest_hr_scores_path(date)
    if not scores_path:
        return jsonify({'error': 'No hr-scores files found', 'date': date}), 404
    scores = _load_scores(scores_path)
    odds_map, _src = _load_player_hr_odds(date)
    # Build normalized sets
    player_names = [p.get('name') for p in scores.get('players', []) if p.get('name')]
    player_keys = [_norm_name_key(nm) for nm in player_names]
    player_key_set = set(player_keys)
    odds_key_set = set(odds_map.keys())
    matched = player_key_set & odds_key_set
    missing_players = sorted([nm for nm in player_names if _norm_name_key(nm) not in odds_key_set])
    unmatched_odds = sorted([nm for nm in odds_key_set if nm not in player_key_set])
    return jsonify({
        'date': date,
        'counts': {
            'players': len(player_key_set),
            'odds': len(odds_key_set),
            'matched': len(matched)
        },
        'missing_for_players': missing_players[:200],
        'unmatched_odds_names': unmatched_odds[:200]
    })


# Simple in-process cache for live HR lookups to avoid heavy repeated queries
_LIVE_HR_CACHE: dict[str, dict] = {}
_LIVE_HR_TTL_SEC = 90

def _fetch_hr_hitters_from_statsapi(date: str) -> dict:
    """Fallback: scan MLB StatsAPI game feeds for home_run events for the date."""
    try:
        sched_url = f"https://statsapi.mlb.com/api/v1/schedule?sportId=1&date={date}"
        rs = requests.get(sched_url, timeout=12)
        dates = (rs.json().get('dates') or []) if rs.status_code == 200 else []
        games = dates[0].get('games', []) if dates else []
    except Exception:
        games = []
    hitters: dict[str, dict] = {}
    for g in games:
        game_pk = g.get('gamePk')
        if not game_pk:
            continue
        try:
            feed_url = f"https://statsapi.mlb.com/api/v1.1/game/{game_pk}/feed/live"
            rf = requests.get(feed_url, timeout=12)
            if rf.status_code != 200:
                continue
            feed = rf.json()
        except Exception:
            continue
        plays = (((feed.get('liveData') or {}).get('plays') or {}).get('allPlays')) or []
        for p in plays:
            res = (p.get('result') or {})
            et = (res.get('eventType') or '').lower()
            ev = (res.get('event') or '').lower()
            if et == 'home_run' or 'home run' in ev:
                matchup = p.get('matchup') or {}
                batter = matchup.get('batter') or {}
                pid = batter.get('id')
                name = batter.get('fullName') or batter.get('lastFirstName')
                if not pid:
                    continue
                key = str(pid)
                rec = hitters.get(key)
                if not rec:
                    hitters[key] = {'name': name, 'hr': 1}
                else:
                    rec['hr'] = int(rec.get('hr') or 0) + 1
    return {'date': date, 'hitters': hitters}


@app.route('/api/live-hr-hitters')
def api_live_hr_hitters():
    """Return hitters who have homered for the given date.
    - If fetcher is available, compute for the requested date (cached ~90s).
    - Else, try to load hr-hitters-<date>.json from data.
    Response: { date, hitters: { <mlbam_id>: { name, hr } } }
    """
    date = request.args.get('date') or _tz_today_str()
    # live path for any requested date if fetcher exists
    if _fetch_hr_hitters_for_date is not None:
        entry = _LIVE_HR_CACHE.get(date)
        now = time.time()
        if not entry or (now - entry.get('ts', 0)) > _LIVE_HR_TTL_SEC:
            try:
                out = _fetch_hr_hitters_for_date(date) or {'date': date, 'hitters': {}}
                # Fallback to StatsAPI if empty
                if not out.get('hitters'):
                    out = _fetch_hr_hitters_from_statsapi(date)
            except Exception:
                # Try StatsAPI as a fallback path
                try:
                    out = _fetch_hr_hitters_from_statsapi(date)
                except Exception:
                    out = {'date': date, 'hitters': {}}
            _LIVE_HR_CACHE[date] = {'ts': now, 'data': out}
        return jsonify(_LIVE_HR_CACHE[date]['data'])

    # historical/static path
    try:
        dd = data_dir()
        p = os.path.join(dd, f'hr-hitters-{date}.json')
        if os.path.exists(p):
            return jsonify(_load_json(p))
    except Exception:
        pass
    return jsonify({'date': date, 'hitters': {}})


_GAME_STATE_CACHE: dict[str, dict] = {}
_GAME_STATE_TTL_SEC = 60


@app.route('/api/game-states')
def api_game_states():
    """Return per-team game state for a date using live MLB StatsAPI schedule.
    Response: { date, teams: { ABBR: 'LIVE'|'FINAL'|'SCHEDULED' } }
    """
    date = request.args.get('date') or _tz_today_str()
    entry = _GAME_STATE_CACHE.get(date)
    now = time.time()
    if entry and (now - entry.get('ts', 0)) <= _GAME_STATE_TTL_SEC:
        return jsonify(entry['data'])
    try:
        url = f"https://statsapi.mlb.com/api/v1/schedule?sportId=1&date={date}&hydrate=linescore"
        r = requests.get(url, timeout=15)
        sched = r.json() if r.status_code == 200 else {}
    except Exception:
        sched = {}
    out_map: dict[str, dict] = {}
    games = (sched.get('dates') or [{}])[0].get('games', []) if sched else []
    for g in games:
        teams_obj = g.get('teams') or {}
        home_t = teams_obj.get('home', {}).get('team', {})
        away_t = teams_obj.get('away', {}).get('team', {})
        home_ab = _team_abbr_from_schedule_team(home_t)
        away_ab = _team_abbr_from_schedule_team(away_t)
        st = (g.get('status') or {})
        abstract = (st.get('abstractGameState') or '').lower()
        detailed = (st.get('detailedState') or '')
        code = 'SCHEDULED'
        label = 'Scheduled'
        # Determine runs from linescore or teams score
        ls = g.get('linescore') or {}
        ls_teams = (ls.get('teams') or {}) if isinstance(ls, dict) else {}
        try:
            home_runs = (ls_teams.get('home') or {}).get('runs')
            away_runs = (ls_teams.get('away') or {}).get('runs')
        except Exception:
            home_runs = away_runs = None
        if home_runs is None:
            try:
                home_runs = teams_obj.get('home', {}).get('score')
            except Exception:
                home_runs = None
        if away_runs is None:
            try:
                away_runs = teams_obj.get('away', {}).get('score')
            except Exception:
                away_runs = None
        try:
            hr_i = int(home_runs) if home_runs is not None else None
        except Exception:
            hr_i = None
        try:
            ar_i = int(away_runs) if away_runs is not None else None
        except Exception:
            ar_i = None
        score_label = None
        if home_ab and away_ab and hr_i is not None and ar_i is not None:
            score_label = f"{away_ab} {ar_i}\u2013{hr_i} {home_ab}"

        if abstract.startswith('live') or abstract in ('in progress','in-progress'):
            code = 'LIVE'
            # Build label from linescore
            ord_inn = ls.get('currentInningOrdinal') or ls.get('currentInning')
            is_top = ls.get('isTopInning')
            half = None
            if isinstance(is_top, bool):
                half = 'Top' if is_top else 'Bot'
            else:
                # fallback to inningState like 'Top'/'Middle'/'End'
                half = (ls.get('inningState') or '').title() or 'In'
            outs = ls.get('outs')
            try:
                outs_i = int(outs)
            except Exception:
                outs_i = None
            outs_txt = (f", {outs_i} out" + ('' if outs_i == 1 else 's')) if outs_i is not None else ''
            if ord_inn:
                label = f"{half} {ord_inn}{outs_txt}"
            else:
                label = 'In Progress'
        elif abstract.startswith('final'):
            code = 'FINAL'
            label = 'Final'
        elif abstract.startswith('preview'):
            code = 'SCHEDULED'
            label = 'Scheduled'
        if home_ab:
            out_map[home_ab] = {'state': code, 'label': label or code.title(), 'score_label': score_label}
        if away_ab:
            out_map[away_ab] = {'state': code, 'label': label or code.title(), 'score_label': score_label}
    data = {'date': date, 'teams': out_map}
    _GAME_STATE_CACHE[date] = {'ts': now, 'data': data}
    return jsonify(data)


def main():
    import argparse
    parser = argparse.ArgumentParser(description='Run HR Scores Flask app (self-contained)')
    parser.add_argument('--port', type=int, default=8010)
    parser.add_argument('--host', type=str, default='127.0.0.1')
    parser.add_argument('--debug', action='store_true', help='Enable Flask debug/reloader')
    args = parser.parse_args()
    app.run(host=args.host, port=args.port, debug=bool(args.debug))


if __name__ == '__main__':
    main()
